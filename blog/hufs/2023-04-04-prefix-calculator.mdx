---
slug: prefix-calcurator
title: Prefix Calcurator
authors: [김지섭_hufs]
tags: [DataStructure, c/c++]
---

Prefix Notation으로 표현된 수식을 계산하는 코드입니다.
실수부와 음수 파싱을 지원합니다.

<!--truncate-->

```c title="typedef" showLineNumbers
typedef enum {
    END,
    OPERATOR,
    NUMBER,
} TokenType;

typedef enum {
    NONE,
    ADD,
    SUB,
    MUL,
    DIV,
} Operator;

typedef struct {
    TokenType type;
    double number;
    Operator op;
} Token;

// 스택 구조체
typedef struct {
    Token *arr;
    int top;
    int size;
} Stack;
```

파싱부를 별도로 구현하기 위하여 Token 구조체를 정의하였습니다.

---

```c title="isEmpty"
int isEmpty(Stack *stack) { return stack->top == -1; }
```

스택이 비어있는지 확인하는 함수입니다. `stack->top` 이 -1이면 비어있는 stack이므로 이와 같이 구현합니다.

---

```c title="isFull"
int isFull(Stack *stack) { return stack->top >= stack->size - 1; }
```

스택이 가득 차있는지 확인하는 함수입니다. `stack->top` 이 스택의 총 크기-1 보다 크거나 같으면 꽉 차있는 stack이므로 이와 같이 구현합니다.

---

```c title="push" showLineNumbers
void push(Stack *stack, Token value) {
    if (isFull(stack)) {
        printf("가득 찬 스택에 push 명령을 수행할 수 없습니다.");
        exit(0);
    }
    stack->arr[++stack->top] = value;
}
```

stack이 가득 차 있으면 오류 문구와 함께 프로그램을 종료시키고, 그렇지 않다면 stack의 top을 1 증가시키고, 해당 위치에 받아온 value를 기입합니다.

---

```c title="pop" showLineNumbers
Token pop(Stack *stack) {
    if (isEmpty(stack)) {
        printf("빈 스택에 pop 명령을 수행할 수 없습니다.");
        exit(0);
    }
    return stack->arr[stack->top--];
}
```

stack이 비어있으면 오류 문구와 함께 프로그램을 종료시키고, 그렇지 않다면 top의 값을 받아온 이후에 top을 1 감소시킵니다. push와 다르게 top의 위치를 나중에 수정합니다.

---

```c title="peek" showLineNumbers
Token peek(Stack *stack) {
    if (isEmpty(stack)) {
        printf("빈 스택에 peek 명령을 수행할 수 없습니다.");
        exit(0);
    }
    return stack->arr[stack->top];
}
```

stack이 비어있다면 오류 문구와 함께 프로그램을 종료시키고, 그렇지 않다면 top의 값을 받아옵니다. pop과 다르게 top의 위치를 수정하지 않습니다.
해당 함수는 아래 프로그램에서는 사용되지 않으나, stack의 구현에서 중요한 함수이기 때문에 구현해보았습니다.

---

```c title="isOperator"
int isOperator(char op) { return getPriority(op) != 0; }
```

postfix, prefix 계산은 infix와 다르게 연산자 우선순위가 명시되기 때문에 getPriority 함수를 이용하여 연산자인지 아닌지를 판별하는 용도로만 사용됩니다.

---

```c title="get_tokens" showLineNumbers
void get_tokens(Token *tokens, char *expression) {
    int tokenCnt = 0; // 현재 받아들이고 있는 토큰의 index입니다.

    for (int i = 0; i < strlen(expression); i++) {
        char c = expression[i];
        char nextC = expression[i + 1];

        // 숫자 포멧의 문자로 시작하는 경우 숫자부를 연속하여 파싱합니다.
        if (('0' <= c && c <= '9') || // 숫자로 시작하거나
            c == '.' ||               // 소수점으로 시작하거나
            (c == '-' && ('0' <= nextC && nextC <= '9')) // 음수로 시작하는 경우
        ) {
            double num = 0;     // 파싱된 숫자
            int floatIndex = 0; // 소숫점 파싱 index
            int sign = 1;       // 부호

            // 음수인 경우
            if (c == '-') {
                sign = -1;
                i++; // 다음 숫자 파싱부에서 부호를 무시합니다.
            }

            for (; i < strlen(expression); i++) {
                char c = expression[i];
                int n = c - '0';
                if ('0' <= c && c <= '9') {
                    // 소수점이 나오기 전까지는 정수부분을 파싱합니다.
                    if (floatIndex == 0)
                        num = num * 10 + n;
                    // 소수점이 나온 후에는 소수부분을 파싱합니다.
                    else {
                        num += n * pow(10, floatIndex);
                        floatIndex--;
                    }
                } else if (c == '.') {

                    if (floatIndex != 0) {
                        printf("소수점이 두 번 이상 나올 수 없습니다.");
                        exit(0);
                    }

                    floatIndex = -1; // 소수부 파싱을 시작합니다.
                } else {
                    // for문이 돌면서 숫자부를 초과하는 곳까지 i가 증가하기
                    // 때문에 1을 줄여줍니다.
                    i--;
                    break;
                }
            }

            // 파싱된 숫자 토큰에 저장
            tokens[tokenCnt].number = num * sign;
            tokens[tokenCnt].type = NUMBER;
            tokens[tokenCnt].op = NONE;

            tokenCnt++;
        }

        // 연산자인 경우
        else if (isOperator(c)) {
            tokens[tokenCnt].type = OPERATOR;
            if (c == '*')
                tokens[tokenCnt].op = MUL;
            else if (c == '/')
                tokens[tokenCnt].op = DIV;
            else if (c == '+')
                tokens[tokenCnt].op = ADD;
            else if (c == '-')
                tokens[tokenCnt].op = SUB;

            tokenCnt++;
        }
    }

    // 마지막으로 END 토큰을 추가합니다.
    tokens[tokenCnt] = (Token){END, 0, NONE};

    return;
}
```

입력받은 문자열을 파싱하여 토큰으로 만들어주는 함수입니다. 파싱 조건은 다음과 같습니다.

- 숫자 파싱
  - 숫자로 시작하거나
  - 소수점으로 시작하거나
  - `-` 기호로 시작되면서 다음 문자가 숫자인 경우
- operator 파싱
  - `+`, `-`, `*`, `/` 중 하나인 경우

숫자를 파싱할 때에 `-` 기호로 시작하면 `sign` 변수를 -1로 설정하고, 최종적으로 파싱된 숫자에 sign을 곱해주어, 음수를 처리합니다.

정수부 파싱은 기존에 받아왔던 수에 `10`을 곱하고, 새로 받아온 수를 더해주면서 진행합니다.

$$
n_{um} = \text{기존에 읽어온 값}
$$

$$
n = \text{읽어온 한 자리 수의 값}
$$

$$
n_{um} = n_{um} * 10 + n
$$

정수부 파싱중에는 `floatIndex`가 0이고, 소수부 기호인 `.`이 감지되면, `floatIndex`를 -1로 설정합니다. 이후 소수부를 파싱할 때, `floatIndex`를 `10`의 지수로 사용하여 소수부를 파싱합니다.

$$
n_{um} = \text{기존에 읽어온 값}
$$

$$
n = \text{읽어온 한 자리 수의 값}
$$

$$
f_i = \text{소수부 파싱을 위한 지수}
$$

$$
n_{um} = n_{um} + n * 10^{f_i}
$$

각 토큰 파싱이 끝날때마다 `tokenCnt`를 증가시켜, 다음 토큰을 저장할 위치를 지정합니다.
마지막에 도달하면 `END`토큰을 추가하여 종료 지점을 명시합니다.

---

```c title="prefix_calculate" showLineNumbers
double prefix_calculate(char *expression) {
    // 연산된 숫자들을 저장하기 위한 스택
    Stack numStack;
    initStack(&numStack, MAX_LEN);

    // 받아온 문자열 파싱 결과
    Token tokens[MAX_LEN];
    get_tokens(tokens, expression);

    // 토큰 목록의 끝 가져오기
    int endIndex = -1;
    for (int i = 0; i < strlen(expression); i++) {
        Token token = tokens[i];
        if (token.type == END) {
            endIndex = i;
            break;
        }
    }

    // 토큰들을 거꾸로 순회하여 postfix 방식으로 계산합니다.
    for (int i = endIndex - 1; i >= 0; i--) {
        Token token = tokens[i];

        // 숫자인 경우
        if (token.type == NUMBER) {
            push(&numStack, token);
        }
        // 연산자인 경우
        else if (token.type == OPERATOR) {
            Token token_a = pop(&numStack);
            Token token_b = pop(&numStack);

            if (token_a.type != NUMBER || token_b.type != NUMBER) {
                printf("잘못된 수식입니다. 숫자가 나와야 할 자리에 연산자가 "
                       "있습니다.");
                exit(0);
            }

            double a = token_a.number;
            double b = token_b.number;

            if (token.op == MUL)
                push(&numStack, (Token){NUMBER, a * b});
            else if (token.op == DIV)
                push(&numStack, (Token){NUMBER, a / b});
            else if (token.op == ADD)
                push(&numStack, (Token){NUMBER, a + b});
            else if (token.op == SUB)
                push(&numStack, (Token){NUMBER, a - b});
        }
    }

    return pop(&numStack).number;
}
```

1. 받아온 문자열을 토큰화합니다.
2. 토큰 목록을 거꾸로 순회하면서 postfix notation 방식으로 계산합니다.
   - 숫자인 경우, stack에 push합니다.
   - 연산자인 경우, stack에서 숫자 2개를 pop하여 연산을 수행하고, 연산 결과를 다시 stack에 push합니다.
3. stack에서 마지막에 남은 숫자를 pop하여 반환합니다.

---

아래는 `* - / 2 7 5 4`의 입력이 주어졌을 때에 동작하는 과정입니다.

| 파싱된 내용 | Stack Operation                | Stack Debug        |
| ----------- | ------------------------------ | ------------------ |
| 4           | push `4`                       | `4`                |
| 5           | push `5`                       | `4`, `5`           |
| 7           | push `7`                       | `4`, `5`, `7`      |
| 2           | push `2`                       | `4`, `5`, `7`, `2` |
| /           | push (pop `2` / pop `7`)       | `4`, `5`, `0.285`  |
| -           | push (pop `0.285` - pop `5`)   | `4`, `-4.715`      |
| \*          | push (pop `-4.715` \* pop `4`) | `-18.86`           |

이후 스택에서 pop을 하여 `-18.86`을 반환합니다.

---

아래는 `* - / 2 -3 .5 1.5`의 입력이 주어졌을 때에 동작하는 과정입니다.

| 파싱된 내용 | Stack Operation                  | Stack Debug             |
| ----------- | -------------------------------- | ----------------------- |
| 1.5         | push `1.5`                       | `1.5`                   |
| .5          | push `0.5`                       | `1.5`, `0.5`            |
| -3          | push `-3`                        | `1.5`, `0.5`, `-3`      |
| 2           | push `2`                         | `1.5`, `0.5`, `-3`, `2` |
| /           | push (pop `2` / pop `-3`)        | `1.5`, `0.5`, `-0.666`  |
| -           | push (pop `-0.666` - pop `0.5`)  | `1.5`, `-1.166`         |
| \*          | push (pop `-1.166` \* pop `1.5`) | `-1.749`                |

이후 스택에서 pop을 하여 `-1.749`을 반환하게 되고, 소숫점 둘째짜리에서 반올림을 하게 되므로, `-1.75`가 출력되게 됩니다.

---

위 코드는 [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)에 의해 포매팅되었으며,
GPT 및 여타 AI 모델을 이용하지 않고 작성되었습니다.
