---
slug: queue
title: Queue 구현
authors: [김지섭]
tags: [DataStructure, c/c++]
---

Queue 구현

<!--truncate-->

```h title="queue.h"
#ifndef QUEUE_H
#define QUEUE_H

#include <cstddef>

class Queue
{
private:
    struct Node
    {
        int data;
        Node *next;
    };

    Node *front;
    Node *rear;
    size_t count;

public:
    Queue();
    ~Queue();
    bool empty();
    size_t size();
    void enqueue(int value);
    void dequeue();
    int getFront();
    int getRear();
};

#endif // QUEUE_H
```

```cpp title="queue.cpp"
#include "queue.h"

// Constructor
Queue::Queue()
{
    front = rear = nullptr;
    count = 0;
}

// Destructor
Queue::~Queue()
{
    while (!empty())
    {
        dequeue();
    }
}

// Check if the queue is empty
bool Queue::empty()
{
    return (front == nullptr);
}

// Return the size of the queue
size_t Queue::size()
{
    return count;
}

// Add an element to the back of the queue
void Queue::enqueue(int value)
{
    Node *newNode = new Node;
    newNode->data = value;
    newNode->next = nullptr;

    if (empty())
    {
        front = rear = newNode;
    }
    else
    {
        rear->next = newNode;
        rear = newNode;
    }

    count++;
}

// Remove the element from the front of the queue
void Queue::dequeue()
{
    if (!empty())
    {
        Node *temp = front;
        front = front->next;
        delete temp;
        count--;

        if (empty())
        {
            rear = nullptr;
        }
    }
}

// Get the value of the front element in the queue and return -1 if the queue is empty
int Queue::getFront()
{
    if (!empty())
    {
        return front->data;
    }
    else
    {
        return -1; // Return an error value
    }
}

// Get the value of the rear element in the queue and return -1 if the queue is empty
int Queue::getRear()
{
    if (!empty())
    {
        return rear->data;
    }
    else
    {
        return -1; // Return an error value
    }
}
```
